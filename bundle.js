!function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=1)}([function(e,n){e.exports=BABYLON},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=t(0),r=t(2),i=t(3),a=t(6),s=document.querySelector("#view"),c=s.clientWidth,l=s.clientHeight,u=new o.Engine(s),v=new o.Scene(u),d=new o.ArcRotateCamera("raymarchingCamera",0,Math.PI/2,2,o.Vector3.Zero(),v);d.layerMask=16777216,d.mode=o.Camera.ORTHOGRAPHIC_CAMERA,d.orthoBottom=-.5,d.orthoTop=.5,d.orthoLeft=-.5,d.orthoRight=.5;const f=o.MeshBuilder.CreatePlane("view",{width:1,height:1},v);f.rotation.y=-Math.PI/2;const h=new i.CloudMaterial("cloudMaterial",v);h.screenSize=new o.Vector2(c,l),h.volumeTexture=new o.Texture("Textures/Volumes/volume_worley.png",v),h.coverageTexture=new o.Texture("Textures/Coverages/coverage_worley.png",v),f.material=h,f.layerMask=16777216;new o.HemisphericLight("light",o.Vector3.Up(),v);const p=new o.FreeCamera("moveCamera",new o.Vector3(0,0,3),v);p.setTarget(o.Vector3.Zero()),p.attachControl(s),p.keysUp.push(87),p.keysDown.push(83),p.keysLeft.push(65),p.keysRight.push(68),p.minZ=.1,p.speed=.1,p.rotation.x=-.35,p.position.y=1.8;const m=o.MeshBuilder.CreateTiledGround("ground",{xmin:-500,xmax:500,zmin:-500,zmax:500,subdivisions:{w:300,h:300}},v),g=new o.StandardMaterial("groundMaterial",v);g.diffuseTexture=new o.Texture("Textures/Surfaces/sand_diffuse.jpg",v),g.specularTexture=new o.Texture("Textures/Surfaces/sand_specular.jpg",v),g.bumpTexture=new o.Texture("Textures/Surfaces/sand_normal.jpg",v),g.ambientTexture=new o.Texture("Textures/Surfaces/sand_ambient.jpg",v),m.material=g;const x=o.MeshBuilder.CreateSphere("skySphere",{diameter:1e3},v),S=new a.SkyMaterial("skyMaterial",v);x.material=S,v.registerBeforeRender(()=>{p.update();const e=p.getViewMatrix();h.viewPosition=p.position,h.cameraMatrix=e,h.fov=p.fov}),u.runRenderLoop(()=>{v.activeCamera=p,f.setEnabled(!1),x.setEnabled(!0),v.render(),v.autoClear=!1,v.activeCamera=d,f.setEnabled(!0),x.setEnabled(!1),v.render(),v.autoClear=!0}),document.getElementById("fullscreenButton").addEventListener("click",()=>{u.switchFullscreen(!0),s.focus()});const y=new r.GUI;y.add(h,"coverage",0,1,.01),y.add(h,"density",0,.2,.001),y.add(h,"altitude",10,100,1)},function(e,n){e.exports=dat},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=t(0),r=t(4),i=t(5);o.Effect.ShadersStore.cloudVertexShader=r,o.Effect.ShadersStore.cloudFragmentShader=i;n.CloudMaterial=class extends o.ShaderMaterial{constructor(e,n){super(e,n,{vertex:"cloud",fragment:"cloud"},{attributes:["position","uv"],uniforms:["worldViewProjection","screenSize","volumeTexture","coverageTexture","viewPosition","cameraMatrix"]}),this.coverage=.4,this.density=.02,this.altitude=40}set screenSize(e){this.setVector2("screenSize",e)}set volumeTexture(e){this.setTexture("volumeTexture",e)}set coverageTexture(e){this.setTexture("coverageTexture",e)}set viewPosition(e){this.setVector3("viewPosition",e)}set fov(e){this.setFloat("fov",e)}set cameraMatrix(e){this.setMatrix("cameraMatrix",e)}set coverage(e){this._coverage=e,this.setFloat("coverageThreshold",1-e)}get coverage(){return this._coverage}set density(e){this._density=e,this.setFloat("volumeScale",e)}get density(){return this._density}set altitude(e){this._altitude=e,this.setFloat("volumeHeight",e)}get altitude(){return this._altitude}needAlphaBlending(){return!0}}},function(e,n){e.exports="#version 300 es\n\nprecision highp float;\n\n// Uniforms\nuniform mat4 worldViewProjection;\n\n// In\nin vec3 position;\nin vec2 uv;\n\n// Out\nout vec2 uvV;\n\nvoid main(void) {\n    gl_Position = worldViewProjection * vec4(position, 1.0);\n\n    uvV = uv;\n}"},function(e,n){e.exports="#version 300 es\n\nprecision highp float;\n\n// Uniforms\nuniform vec2 screenSize;\nuniform sampler2D volumeTexture;\nuniform sampler2D coverageTexture;\nuniform vec3 viewPosition;\nuniform vec3 viewRotation;\nuniform mat4 cameraMatrix;\nuniform float fov;\nuniform float coverageThreshold;\nuniform float volumeThreshold;\nuniform float volumeScale;\nuniform float volumeHeight;\n\n// In\nin vec2 uvV;\n\n// Out\nout vec4 fragmentColor;\n\nconst int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\nconst float STEP_LENGTH = 0.1;\n\nconst float VOLUME_RADIUS = 1.5;\n\nconst float cloudHeight = 10.0;\n\nfloat sphereSDF(vec3 position, float radius) {\n    return length(position) - radius;\n}\n\nfloat boxSDF(vec3 pos, vec3 center, vec3 size) {\n    return length(max(abs(pos-center) - size, 0.0));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    // TODO Why 1.14 scaling?\n    float z = size.y / tan(fieldOfView / 1.14);\n    return normalize(vec3(xy, z));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    return boxSDF(samplePoint, vec3(0.0, volumeHeight, 0.0), vec3(1000.0, cloudHeight, 1000.0));\n    // return sphereSDF(samplePoint, VOLUME_RADIUS);\n}\n\nfloat getColor(vec3 position) {\n    vec3 texPos = mod(floor(position * 255.0), vec3(256.0, 256.0, 256.0));\n\n    int x = int(texPos.x);\n    int y = int(texPos.z);\n    int z = int(texPos.y);\n\n    int channel = z % 4;\n    int layerStack = z / 4;\n\n    int startX = layerStack % 8;\n    int startY = layerStack / 8;\n\n    int texX = startX * 256 + x;\n    int texY = (7 - startY) * 256 + y;\n\n    vec4 texel = texelFetch(volumeTexture, ivec2(texX, texY), 0);\n\n    if (channel == 0) {\n        return texel.r;\n    } else if (channel == 1) {\n        return texel.g;\n    } else if (channel == 2) {\n        return texel.b;\n    } else if (channel == 3) {\n        return texel.a;\n    }\n\n    return 0.0;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nfloat computeVolume(vec3 eye, vec3 marchingDirection) {\n    float alpha = 0.0;\n\n    float dist = shortestDistanceToSurface(eye, marchingDirection, MIN_DIST, MAX_DIST);\n\n    if (dist > MAX_DIST - EPSILON) {\n        return 0.0;\n    }\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float depth = dist + float(i) * STEP_LENGTH;\n        vec3 position = eye + depth * marchingDirection;\n        float dist = sceneSDF(position);\n\n        if (dist <= 0.0) {\n            vec3 volumePosition = position * 0.1;\n            vec2 coveragePosition = volumePosition.xz * 0.03;\n\n            float stepAlpha = 0.0;\n            \n            float coverage = texture(coverageTexture, coveragePosition).x;\n            \n            if (coverage > coverageThreshold) {\n                \n                float coverageRatio = (coverage - coverageThreshold) / (1.0 - coverageThreshold);\n\n                if (position.y < (volumeHeight - cloudHeight) + cloudHeight * coverageRatio) {\n\n                    stepAlpha = getColor(volumePosition);\n                    if (stepAlpha < volumeThreshold) {\n                        stepAlpha = 0.0;\n                    } else {\n                        stepAlpha = stepAlpha;\n                    }\n                }\n            }\n\n\t\t\talpha = alpha + stepAlpha * volumeScale;\n        }\n    }\n\n    return alpha;\n}\n\nvoid main(void) {\n    vec2 fragCoord = (gl_FragCoord.xy - 0.5);\n\n    vec3 viewDir = rayDirection(fov, screenSize, fragCoord);\n    vec3 worldDir = (inverse(cameraMatrix) * vec4(viewDir, 0.0)).xyz;\n\n    vec3 eye = viewPosition;\n\n    float alpha = computeVolume(eye, worldDir);\n\n    fragmentColor = vec4(1.0, 1.0, 1.0, alpha);\n}"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=t(0),r=t(7),i=t(8);o.Effect.ShadersStore.skyVertexShader=r,o.Effect.ShadersStore.skyFragmentShader=i;n.SkyMaterial=class extends o.ShaderMaterial{constructor(e,n){super(e,n,{vertex:"sky",fragment:"sky"},{attributes:["position","uv"],uniforms:["worldViewProjection"]}),this.backFaceCulling=!1}}},function(e,n){e.exports="#version 300 es\n\nprecision highp float;\n\n// Uniforms\nuniform mat4 worldViewProjection;\n\n// In\nin vec3 position;\nin vec2 uv;\n\n// Out\nout vec2 uvV;\n\nvoid main(void) {\n    gl_Position = worldViewProjection * vec4(position, 1.0);\n\n    uvV = uv;\n}"},function(e,n){e.exports="#version 300 es\n\nprecision highp float;\n\n// In\nin vec2 uvV;\n\n// Out\nout vec4 fragmentColor;\n\n// const vec3 top = vec3(0.2, 0.031, 0.404);\n// const vec3 bottom = vec3(0.188, 0.812, 0.816);\n\nconst vec3 top = vec3(0.675, 0.878, 0.976);\nconst vec3 bottom = vec3(1, 0.945, 0.922);\n\n\nvoid main(void) {\n    float ratio = uvV.y;\n    vec3 skyColor = mix(top, bottom, ratio);\n\n    fragmentColor = vec4(skyColor, 1.0);\n}"}]);